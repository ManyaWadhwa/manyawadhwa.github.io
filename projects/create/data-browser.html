<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <title>Data Browser</title> -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'SF Pro Display', Roboto, 'Helvetica Neue', Helvetica, Arial, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #ffffff;
            color: #1f2933;
            padding: 0;
            margin: 0;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            font-size: 13px;
        }
        
        .container {
            width: 100%;
            max-width: 100%;
            margin: 0;
            background: white;
            padding: 24px;
            border-radius: 0;
            box-shadow: none;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
            padding: 10px 14px;
            background: #f9fafb;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.4);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: 500;
            color: #4b5563;
            font-size: 13px;
            letter-spacing: -0.01em;
        }
        
        select, input {
            padding: 6px 10px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            border-radius: 6px;
            font-size: 13px;
            min-width: 160px;
            font-family: inherit;
            background: white;
        }
        
        button {
            padding: 7px 14px;
            background: #111827;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            transition: background-color 0.15s ease;
            letter-spacing: -0.01em;
        }
        
        button:hover {
            background: #020617;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .data-display {
            margin-top: 20px;
            padding: 16px;
            background-color: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        
        .data-section {
            margin-bottom: 20px;
        }
        
        .data-section-card {
            background: white;
            border-radius: 10px;
            border: 1px solid rgba(209, 213, 219, 0.9);
            padding: 18px 18px 16px;
            margin-bottom: 16px;
        }
        
        .query-section {
            background: #f9fafb;
            border-radius: 10px;
            padding: 18px 18px 16px;
            margin-bottom: 16px;
            border: 1px solid rgba(209, 213, 219, 0.9);
        }
        
        .query-label {
            font-size: 12px;
            font-weight: 600;
            color: #4b5563;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .data-section h3 {
            color: #111827;
            margin-bottom: 4px;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.02em;
        }
        
        .data-section-subtitle {
            color: #6b7280;
            font-size: 13px;
            margin-bottom: 10px;
            font-weight: 400;
            line-height: 1.5;
        }
        
        .statistics-info {
            display: inline-block;
            margin-left: 8px;
            color: #57068C;
            font-weight: 500;
        }
        
        .data-content {
            background: #f9fafb;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        
        .source-section {
            border-left: 4px solid rgba(87, 6, 140, 0.3);
        }
        
        .source-section h3 {
            color: #57068C;
        }
        
        .reasoning-section {
            border-left: 4px solid rgba(87, 6, 140, 0.5);
        }
        
        .reasoning-section h3 {
            color: #57068C;
        }
        
        .prediction-section {
            border-left: 4px solid #57068C;
        }
        
        .prediction-section h3 {
            color: #57068C;
        }
        
        .reasoning-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: 0;
            margin: 0;
        }
        
        .reasoning-header h3 {
            margin: 0;
            flex: 1;
        }
        
        .reasoning-toggle {
            font-size: 16px;
            color: #4b5563;
            margin-left: 12px;
            transition: transform 0.2s ease;
        }
        
        .reasoning-section.collapsed .reasoning-toggle {
            transform: rotate(-90deg);
        }
        
        .reasoning-content {
            max-height: 320px;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 14px;
            background: #f9fafb;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'SF Pro Display', Roboto, 'Helvetica Neue', Helvetica, Arial, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 13px;
            line-height: 1.6;
            color: #111827;
            letter-spacing: -0.01em;
            /* Better handling of empty lines and spacing */
            tab-size: 4;
        }
        
        .reasoning-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .reasoning-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .reasoning-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .reasoning-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .reasoning-section.collapsed .reasoning-content {
            display: none;
        }
        
        .query {
            font-size: 14px;
            color: #111827;
            line-height: 1.6;
            letter-spacing: -0.01em;
        }
        
        .source-path {
            font-family: 'SF Mono', 'Monaco', 'Menlo', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
            font-size: 14px;
            color: #111827;
            word-break: break-all;
            line-height: 1.8;
            letter-spacing: 0.01em;
        }
        
        .paths-container {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
        }
        
        .paths-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .paths-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .paths-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .paths-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .paths-table {
            width: 100%;
            max-width: 90%;
            margin: 0 auto;
            border-collapse: separate;
            border-spacing: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'SF Pro Display', Roboto, 'Helvetica Neue', Helvetica, Arial, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
        }
        
        .paths-table thead {
            background-color: #f8f9fa;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .paths-table th {
            padding: 10px 12px;
            text-align: left;
            font-weight: 600;
            color: #111827;
            border-bottom: 1px solid #e5e7eb;
            font-size: 13px;
            letter-spacing: -0.01em;
        }
        
        .paths-table th:first-child {
            position: sticky;
            left: 0;
            background-color: #f8f9fa;
            z-index: 11;
        }
        
        .paths-table td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(209, 213, 219, 0.8);
            vertical-align: top;
            line-height: 1.6;
            letter-spacing: -0.01em;
        }
        
        .paths-table tbody tr {
            background: white;
            transition: background-color 0.2s ease;
        }
        
        .paths-table tbody tr:hover {
            background-color: rgba(87, 6, 140, 0.03);
        }
        
        .paths-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        .paths-table tbody tr:first-child td:first-child {
            border-top-left-radius: 8px;
        }
        
        .paths-table tbody tr:first-child td:last-child {
            border-top-right-radius: 8px;
        }
        
        .paths-table tbody tr:last-child td:first-child {
            border-bottom-left-radius: 8px;
        }
        
        .paths-table tbody tr:last-child td:last-child {
            border-bottom-right-radius: 8px;
        }
        
        .path-cell {
            padding-left: 15px !important;
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 1;
        }
        
        .paths-table tbody tr:hover .path-cell {
            background-color: rgba(87, 6, 140, 0.03);
        }
        
        .path-step {
            padding: 10px 12px;
            background: #f9fafb;
            border-radius: 6px;
            border-left: 3px solid #111827;
            line-height: 1.6;
            font-size: 14px;
        }
        
        .path-entity {
            font-weight: normal;
            color: #111827;
            font-family: inherit;
            font-size: 14px;
        }
        
        .path-relation {
            color: #374151;
            font-style: normal;
            font-weight: normal;
            font-family: inherit;
            font-size: 14px;
        }
        
        .path-arrow {
            color: #6b7280;
            font-weight: normal;
            margin: 0 4px;
            font-family: inherit;
            font-size: 14px;
        }
        
        .triple-start,
        .triple-end {
            color: #9ca3af;
            font-weight: normal;
            margin: 0 2px;
            font-size: 14px;
        }
        
        .score-cell {
            text-align: center;
            font-weight: 500;
        }
        
        .score-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .score-valid {
            background-color: #d4edda;
            color: #155724;
        }
        
        .score-invalid {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .score-factual {
            background-color: #d4edda;
            color: #155724;
        }
        
        .score-not-factual {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .score-uncertain {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .quality-stars {
            display: inline-flex;
            gap: 2px;
            align-items: center;
        }
        
        .quality-star {
            color: #ffc107;
            font-size: 14px;
        }
        
        .quality-star.empty {
            color: #e0e0e0;
        }
        
        .score-na {
            color: #999;
            font-style: italic;
        }
        
        .filter-bar {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px;
            background: #f9fafb;
            border-radius: 8px;
            border: 1px solid rgba(209, 213, 219, 0.8);
            flex-wrap: wrap;
        }
        
        .filter-control {
            padding: 6px 10px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
            background: white;
            color: #1f2933;
            cursor: pointer;
            transition: border-color 0.15s;
        }
        
        .filter-control:hover {
            border-color: #57068C;
        }
        
        .filter-control:focus {
            outline: none;
            border-color: #57068C;
            box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.1);
        }
        
        .filter-search {
            flex: 1;
            min-width: 200px;
        }
        
        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 13px;
            color: #1f2933;
            user-select: none;
        }
        
        .filter-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #57068C;
        }
        
        .filter-checkbox span {
            white-space: nowrap;
        }
        
        .navigation {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 16px;
            padding: 10px 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid rgba(209, 213, 219, 0.9);
            flex-wrap: wrap;
        }
        
        .navigation-hint {
            margin-left: auto;
            font-size: 12px;
            color: #6c757d;
            font-style: italic;
        }
        
        .index-input {
            width: 80px;
            text-align: center;
        }
        
        .index-info {
            margin-left: auto;
            color: #4b5563;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        .error {
            color: #b91c1c;
            background-color: #fef2f2;
            padding: 10px 12px;
            border-radius: 6px;
            margin-top: 12px;
            border: 1px solid #fecaca;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .loading {
            text-align: center;
            padding: 14px;
            color: #6b7280;
            font-size: 13px;
            font-weight: 500;
        }
        
        /* Model + variation tabs */
        .data-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 4px 0;
        }
        .data-tab {
            padding: 10px 18px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            background: #f9fafb;
            color: #4b5563;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease;
        }
        .data-tab:hover {
            background: #f3f4f6;
            border-color: rgba(87, 6, 140, 0.3);
            color: #111827;
        }
        .data-tab.active {
            background: #111827;
            border-color: #111827;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="data-tabs" class="data-tabs" role="tablist"></div>
        
        <div id="data-display" class="data-display" style="display: none;">
            <div class="navigation">
                <button id="prev-btn">‚Üê Back</button>
                <button id="next-btn">Next ‚Üí</button>
                <label for="index-input" style="margin-left: 12px;">Go to index:</label>
                <input type="number" id="index-input" class="index-input" min="0" value="0">
                <button id="jump-btn">Jump</button>
                <div class="index-info" id="index-info"></div>
                <div class="navigation-hint">Use ‚Üê ‚Üí arrow keys to navigate</div>
            </div>
            
            <div class="data-section">
                <div class="query-section">
                    <div class="query-label">üîç Question</div>
                    <div class="query" id="query-display"></div>
                </div>
            </div>
            
            <!-- <div class="data-section source-section">
                <div class="data-section-card">
                    <h3>Source Path</h3>
                    <div class="data-section-subtitle">Input triples used to generate candidate paths</div>
                    <div class="data-content">
                        <div class="source-path" id="source-path-display"></div>
                    </div>
                </div>
            </div> -->
            
            <div class="data-section prediction-section">
                <div class="data-section-card">
                    <h3>Predictions</h3>
                    <!-- <div class="data-section-subtitle">
                        Ranked inferred relationship chains
                        <span class="statistics-info" id="predictions-stats"></span>
                    </div> -->
                    <div class="filter-bar">
                        <select id="filter-quality" class="filter-control">
                            <option value="" selected>Quality: All</option>
                            <option value="0">Quality ‚â• 0</option>
                            <option value="1">Quality ‚â• 1</option>
                            <option value="2">Quality ‚â• 2</option>
                            <option value="3">Quality ‚â• 3</option>
                            <option value="4">Quality ‚â• 4</option>
                            <option value="5">Quality ‚â• 5</option>
                        </select>
                        <input type="text" id="filter-search" class="filter-control filter-search" placeholder="Search entity‚Ä¶">
                    </div>
                    <div class="data-content paths-container">
                        <table class="paths-table" id="paths-display">
                            <thead>
                                <tr>
                                    <th>Path</th>
                                    <th>Quality</th>
                                </tr>
                            </thead>
                            <tbody id="paths-tbody">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div class="data-section reasoning-section" id="reasoning-section" style="display: none;">
                <div class="data-section-card">
                    <div class="reasoning-header" id="reasoning-header">
                        <h3>Reasoning</h3>
                        <span class="reasoning-toggle">‚ñº</span>
                    </div>
                    <div class="data-section-subtitle">
                        Model reasoning for this instance
                        <span class="statistics-info" id="reasoning-token-count"></span>
                    </div>
                    <div class="data-content">
                        <div class="reasoning-content" id="reasoning-display"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="error-message" class="error" style="display: none;"></div>
        <div id="loading" class="loading" style="display: none;">Loading dataset... This may take a moment.</div>
        <div id="pyodide-loading" class="loading" style="display: none;">Initializing Python runtime...</div>
    </div>
    
    <!-- Load Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    
    <script type="module">
        // Tabs: [{ label: "ModelName / variation", file: "data/..." }], built from Python DATASET_CONFIG after init
        let DATA_TABS = [];

        // Set to true (or add ?debug=1 to URL) to log path processing details in the console
        const DEBUG_PATHS = typeof URLSearchParams !== 'undefined' && new URLSearchParams(window.location.search).get('debug') === '1';
        if (DEBUG_PATHS) console.log('[Paths debug] Enabled. You will see input paths_0, Python output, and filtered paths in the console.');

        // In-memory dataset cache
        let datasetCache = {};
        let currentDataset = null;
        let currentIndex = 0;
        let totalInstances = 0;
        let pyodide = null;

        // Initialize Pyodide (Python runtime in browser)
        async function initPyodide() {
            if (pyodide) return; // Already initialized
            
            document.getElementById('pyodide-loading').style.display = 'block';
            try {
                pyodide = await loadPyodide();
                // Redirect Python print() to browser console for debugging
                pyodide.setStdout({ batched: (msg) => console.log('[Python]', msg) });
                pyodide.setStderr({ batched: (msg) => console.warn('[Python stderr]', msg) });

                // Try to load python_functions.py from the server
                let pythonCode = '';
                
                // Skip file fetch if running from file:// protocol (won't work due to CORS)
                const isFileProtocol = window.location.protocol === 'file:';
                
                if (!isFileProtocol) {
                    // Determine the base path from current page location
                    const currentPath = window.location.pathname;
                    const basePath = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
                    
                    // Try different possible paths relative to current page
                    const possiblePaths = [
                        'python_functions.py',  // Same directory
                        './python_functions.py',  // Same directory (explicit)
                        basePath + 'python_functions.py',  // Relative to current page
                        '/projects/create/python_functions.py',  // Absolute path (GitHub Pages)
                        '../python_functions.py'  // Parent directory (if needed)
                    ];
                    
                    console.log('Attempting to load python_functions.py from paths:', possiblePaths);
                    console.log('Current path:', currentPath, 'Base path:', basePath);
                    
                    let loaded = false;
                    let lastError = null;
                    
                    for (const path of possiblePaths) {
                        try {
                            console.log(`Trying to fetch: ${path}`);
                            // Add cache-busting query parameter to force fresh fetch
                            const cacheBuster = `?t=${Date.now()}`;
                            const response = await fetch(path + cacheBuster, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'text/plain, text/x-python, */*',
                                    'Cache-Control': 'no-cache'
                                },
                                cache: 'no-store'  // Force bypass cache
                            });
                            console.log(`Response status for ${path}:`, response.status, response.statusText, 'Content-Type:', response.headers.get('content-type'));
                            
                            if (response.ok && response.status === 200) {
                                const text = await response.text();
                                console.log(`File content preview (first 100 chars):`, text.substring(0, 100));
                                
                                // DEBUG: Check if file contains expected models
                                if (text.includes('DATASET_CONFIG')) {
                                    console.log('=== FILE CONTENT CHECK ===');
                                    // Extract DATASET_CONFIG section for verification
                                    const configMatch = text.match(/DATASET_CONFIG\s*=\s*\{[\s\S]*?\n\}/);
                                    if (configMatch) {
                                        console.log('DATASET_CONFIG found in file:', configMatch[0].substring(0, 200));
                                    }
                                    // Check for specific model names (case-insensitive)
                                    const modelNames = ['GPT-4.1-mini', 'gpt-4.1-mini', 'Olmo-31-32B', 'olmo-31-32b'];
                                    modelNames.forEach(name => {
                                        if (text.includes(name)) {
                                            console.log(`  ‚úì Found model name in file: "${name}"`);
                                        }
                                    });
                                    console.log('=== END FILE CHECK ===');
                                }
                                
                                // Verify it looks like Python code (function definitions)
                                if (text && text.trim().length > 0) {
                                    if (text.includes('def ') || text.includes('import ')) {
                                        pythonCode = text;
                                        loaded = true;
                                        console.log(`‚úì Successfully loaded python_functions.py from ${path} (${text.length} characters)`);
                                        break;
                                    } else {
                                        console.warn(`File ${path} doesn't look like Python code (missing function definitions)`);
                                    }
                                } else {
                                    console.warn(`File ${path} is empty`);
                                }
                            } else {
                                console.warn(`File ${path} returned status ${response.status} ${response.statusText}`);
                            }
                        } catch (e) {
                            lastError = e;
                            console.warn(`Failed to fetch ${path}:`, e.message);
                            // Continue to next path
                            continue;
                        }
                    }
                    
                    if (!loaded) {
                        const errorMsg = `Could not load python_functions.py from any path. Last error: ${lastError?.message || 'Unknown error'}. Tried paths: ${possiblePaths.join(', ')}`;
                        console.error(errorMsg);
                        throw new Error(errorMsg + '. Please ensure python_functions.py is accessible from the same directory as this HTML file.');
                    }
                } else {
                    throw new Error('Cannot load python_functions.py when running from file:// protocol due to CORS restrictions. Please serve this page from a web server (e.g., GitHub Pages, localhost, or a web server).');
                }
                
                // Ensure we have Python code loaded
                if (!pythonCode) {
                    throw new Error('Failed to load python_functions.py. The file is required for this application to work.');
                }
                
                // Execute the Python code
                try {
                    pyodide.runPython(pythonCode);
                    console.log('Python code executed successfully');
                } catch (error) {
                    console.error('Error executing Python code:', error);
                    console.error('Python code that failed:', pythonCode.substring(0, 200));
                    throw new Error('Failed to execute Python code: ' + error.message);
                }
                
                // Build DATA_TABS from Python DATASET_CONFIG for model+variation tabs
                try {
                    if (pyodide.globals.has('DATASET_CONFIG')) {
                        const jsonStr = pyodide.runPython('import json; json.dumps(DATASET_CONFIG)');
                        const config = JSON.parse(jsonStr);
                        DATA_TABS = [];
                        for (const model of Object.keys(config)) {
                            for (const variation of Object.keys(config[model])) {
                                const file = config[model][variation];
                                if (file && typeof file === 'string') {
                                    DATA_TABS.push({ label: `${model} / ${variation}`, file });
                                }
                            }
                        }
                        if (DATA_TABS.length === 0) {
                            DATA_TABS = [{ label: 'Default', file: 'data/GPT-4.1_model_name_gpt-4.1_variation_original.jsonl' }];
                        }
                        console.log('DATA_TABS:', DATA_TABS);
                    }
                } catch (e) {
                    console.warn('Could not load DATASET_CONFIG for tabs, using default:', e);
                    DATA_TABS = [{ label: 'Default', file: 'data/GPT-4.1_model_name_gpt-4.1_variation_original.jsonl' }];
                }

                document.getElementById('pyodide-loading').style.display = 'none';
                console.log('Pyodide initialized successfully');
            } catch (error) {
                console.error('Failed to initialize Pyodide:', error);
                document.getElementById('pyodide-loading').style.display = 'none';
                const errorMsg = `Failed to initialize Python runtime: ${error.message}. Please check the browser console for details.`;
                document.getElementById('error-message').textContent = errorMsg;
                document.getElementById('error-message').style.display = 'block';
                throw error; // Re-throw to prevent silent failures
            }
        }

        // Call Python function wrapper
        async function callPythonFunction(funcName, ...args) {
            if (!pyodide) {
                await initPyodide();
            }
            
            if (!pyodide) {
                throw new Error('Pyodide not available');
            }
            
            try {
                // Get the Python function
                const pyFunc = pyodide.globals.get(funcName);
                if (!pyFunc) {
                    throw new Error(`Python function ${funcName} not found`);
                }
                
                // Convert JavaScript arguments to Python objects
                const pyArgs = args.map(arg => {
                    if (arg === null || arg === undefined) {
                        return pyodide.globals.get('None');
                    }
                    return pyodide.toPy(arg);
                });
                
                // Call the function
                const result = pyFunc(...pyArgs);
                
                // Convert Python result back to JavaScript
                // Pyodide automatically converts most types, but for complex types use JSON
                if (result === null || result === undefined) {
                    return null;
                }
                
                // For simple types, Pyodide auto-converts
                if (typeof result === 'string' || typeof result === 'number' || typeof result === 'boolean') {
                    return result;
                }
                
                // For lists and dicts, use JSON serialization for reliability
                // Store result in a Python variable first
                pyodide.globals.set('_temp_py_result', result);
                try {
                    const jsonStr = pyodide.runPython('import json; json.dumps(_temp_py_result)');
                    const jsResult = JSON.parse(jsonStr);
                    pyodide.globals.delete('_temp_py_result');
                    return jsResult;
                } catch (e) {
                    // Clean up temp variable
                    try {
                        pyodide.globals.delete('_temp_py_result');
                    } catch (cleanupError) {
                        // Ignore cleanup errors
                    }
                    // If JSON fails, return as-is (Pyodide might have auto-converted)
                    console.warn('JSON conversion failed, using direct result:', e);
                    return result;
                }
            } catch (error) {
                console.error(`Error calling Python function ${funcName}:`, error);
                throw error;
            }
        }

        // Format source path from triple labels (with Python fallback)
        async function formatSourcePath(triple1_labels, triple2_labels, triple3_labels) {
            if (pyodide) {
                try {
                    let result = await callPythonFunction('format_source_path', triple1_labels, triple2_labels, triple3_labels);
                    // Clean up formatting: remove single quotes and replace square brackets with round brackets
                    result = result.replace(/'/g, '');
                    result = result.replace(/\[/g, '(');
                    result = result.replace(/\]/g, ')');
                    return result;
                } catch (error) {
                    console.warn('Python function failed, using JS fallback:', error);
                }
            }
            // JavaScript fallback
            const parts = [];
            if (triple1_labels) {
                let str = String(triple1_labels);
                // Remove single quotes
                str = str.replace(/'/g, '');
                // Replace square brackets with round brackets
                str = str.replace(/\[/g, '(');
                str = str.replace(/\]/g, ')');
                // Add space after commas (but not if already present)
                str = str.replace(/,(?!\s)/g, ', ');
                parts.push(str);
            }
            if (triple2_labels) {
                let str = String(triple2_labels);
                str = str.replace(/'/g, '');
                str = str.replace(/\[/g, '(');
                str = str.replace(/\]/g, ')');
                str = str.replace(/,(?!\s)/g, ', ');
                parts.push(str);
            }
            if (triple3_labels) {
                let str = String(triple3_labels);
                str = str.replace(/'/g, '');
                str = str.replace(/\[/g, '(');
                str = str.replace(/\]/g, ')');
                str = str.replace(/,(?!\s)/g, ', ');
                parts.push(str);
            }
            return parts.join(' + ');
        }

        // Format paths_0 array to list of lists (with Python fallback)
        async function formatPaths(paths_0) {
            if (pyodide) {
                try {
                    return await callPythonFunction('format_paths', paths_0);
                } catch (error) {
                    console.warn('Python function failed, using JS fallback:', error);
                }
            }
            // JavaScript fallback
            if (!paths_0) return [];
            
            if (Array.isArray(paths_0)) {
                return paths_0.map(path => {
                    if (Array.isArray(path)) {
                        return path;
                    } else {
                        return [path];
                    }
                });
            } else {
                return [[paths_0]];
            }
        }

        // Process paths with scores (using Python) - for single instance
        async function processPathsWithScores(instance) {
            if (DEBUG_PATHS) {
                const paths0 = instance.paths_0;
                console.group('[DEBUG] process_paths_with_scores input');
                console.log('paths_0 type:', typeof paths0);
                console.log('paths_0 is string:', typeof paths0 === 'string');
                if (typeof paths0 === 'string') console.log('paths_0 (first 200 chars):', paths0.substring(0, 200));
                else console.log('paths_0 length:', Array.isArray(paths0) ? paths0.length : (paths0 ? 1 : 0), 'sample:', paths0 ? (Array.isArray(paths0) ? paths0[0] : paths0) : null);
                console.log('validity_per_path_0:', instance.validity_per_path_0);
                console.log('factuality_scores_0 / factualiy_scores_0:', instance.factuality_scores_0 || instance.factualiy_scores_0);
                console.log('min_salience_scores_0:', instance.min_salience_scores_0);
                console.groupEnd();
            }
            if (pyodide) {
                try {
                    const result = await callPythonFunction('process_paths_with_scores', instance);
                    if (DEBUG_PATHS) {
                        console.group('[DEBUG] process_paths_with_scores output');
                        console.log('processed_paths length:', result.length);
                        result.forEach((entry, i) => {
                            console.log(`  [${i}] path:`, entry.path, 'valid:', entry.valid, 'factual:', entry.factual, 'quality:', entry.quality);
                        });
                        console.groupEnd();
                    }
                    return result;
                } catch (error) {
                    console.warn('Python function failed, using JS fallback:', error);
                }
            }
            // JavaScript fallback
            if (!instance || !instance.paths_0) return [];
            
            const paths_0 = instance.paths_0 || [];
            const validityScores = instance.validity_per_path_0 || [];
            const factualScores = instance.factuality_scores_0 || instance.factualiy_scores_0 || [];
            const qualityScores = instance.min_salience_scores_0 || [];
            
            const formattedPaths = await formatPaths(paths_0);
            
            return formattedPaths.map((path, index) => ({
                path: Array.isArray(path) ? path : [path],
                valid: validityScores[index] !== undefined ? validityScores[index] : null,
                factual: factualScores[index] !== undefined ? factualScores[index] : null,
                quality: qualityScores[index] !== undefined ? qualityScores[index] : null
            }));
        }

        // Pre-process entire dataset (using Python)
        async function preprocessDataset(dataset) {
            if (pyodide) {
                try {
                    return await callPythonFunction('preprocess_dataset', dataset);
                } catch (error) {
                    console.warn('Python preprocessing failed, using JS fallback:', error);
                }
            }
            // JavaScript fallback - process each instance
            const processedInstances = await Promise.all(
                dataset.map(async (instance) => {
                    const processedInstance = {...instance};
                    processedInstance.processed_paths = await processPathsWithScores(instance);
                    return processedInstance;
                })
            );
            return processedInstances;
        }

        // Load dataset from local JSONL file on disk
        async function loadDatasetFromFile(filePath) {
            const cacheKey = filePath;
            
            if (datasetCache[cacheKey]) {
                return datasetCache[cacheKey];
            }

            showLoading(true);
            hideError();

            try {
                // Fetch local JSONL file via HTTP
                console.log(`Attempting to load dataset from: ${filePath}`);
                const response = await fetch(filePath);
                console.log(`Response status: ${response.status} ${response.statusText}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const text = await response.text();

                // Parse JSONL (one JSON object per line)
                const dataset = [];
                const maxInstances = 200;
                const lines = text.split('\n');

                for (let i = 0; i < lines.length && dataset.length < maxInstances; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    try {
                        const obj = JSON.parse(line);
                        dataset.push(obj);
                    } catch (e) {
                        console.warn(`Skipping invalid JSONL line ${i}:`, e);
                    }
                }

                if (dataset.length === 0) {
                    throw new Error('No data found in local dataset file');
                }

                // Pre-process the dataset (add processed_paths to each instance)
                document.getElementById('loading').textContent = 
                    `Pre-processing dataset...`;
                const processedDataset = await preprocessDataset(dataset);

                datasetCache[cacheKey] = processedDataset;
                showLoading(false);
                return processedDataset;
            } catch (error) {
                showLoading(false);
                console.error('Error loading dataset:', error);
                throw new Error(`Failed to load local dataset file "${filePath}": ${error.message}. Please check that the file exists and is accessible from the web server.`);
            }
        }

        // Display data for a specific index
        async function displayData(index) {
            if (!currentDataset || index < 0 || index >= currentDataset.length) {
                return;
            }

            const instance = currentDataset[index];
            currentIndex = index;

            // Format and display query
            const query = instance.query || '';
            document.getElementById('query-display').textContent = query || '(empty)';

            // // Format and display source path (using Python if available)
            // const triple1_labels = instance.triple1_labels || '';
            // const triple2_labels = instance.triple2_labels || '';
            // const triple3_labels = instance.triple3_labels || '';
            // const sourcePath = await formatSourcePath(triple1_labels, triple2_labels, triple3_labels);
            // document.getElementById('source-path-display').textContent = sourcePath || '(empty)';

            // Check for and display reasoning_0 if it exists
            const reasoningSection = document.getElementById('reasoning-section');
            const reasoningDisplay = document.getElementById('reasoning-display');
            
            if (instance.reasoning_0 !== undefined && instance.reasoning_0 !== null && instance.reasoning_0 !== '') {
                // Format reasoning text - handle newlines and other escape sequences
                let reasoningText = String(instance.reasoning_0);
                
                // Try to decode if it's JSON-encoded (some datasets store strings as JSON)
                try {
                    if (reasoningText.startsWith('"') && reasoningText.endsWith('"')) {
                        const decoded = JSON.parse(reasoningText);
                        if (typeof decoded === 'string') {
                            reasoningText = decoded;
                        }
                    }
                } catch (e) {
                    // Not JSON-encoded, continue with original text
                }
                
                // Handle various newline representations
                // Replace literal \n with actual newlines (handles escaped strings)
                reasoningText = reasoningText.replace(/\\n/g, '\n');
                // Replace \r\n with newlines (Windows line endings)
                reasoningText = reasoningText.replace(/\\r\\n/g, '\n');
                // Replace \r with newlines (old Mac line endings)
                reasoningText = reasoningText.replace(/\\r/g, '\n');
                // Replace literal \t with tabs
                reasoningText = reasoningText.replace(/\\t/g, '\t');
                // Handle other common escape sequences
                reasoningText = reasoningText.replace(/\\"/g, '"');
                reasoningText = reasoningText.replace(/\\'/g, "'");
                reasoningText = reasoningText.replace(/\\\\/g, '\\');
                
                // Clean up excessive whitespace while preserving intentional formatting
                // Replace 3+ consecutive newlines with double newline (paragraph break)
                reasoningText = reasoningText.replace(/\n{3,}/g, '\n\n');
                // Replace spaces followed by newline with just newline (trailing spaces)
                reasoningText = reasoningText.replace(/ +\n/g, '\n');
                // Replace newline followed by spaces with just newline (leading spaces)
                reasoningText = reasoningText.replace(/\n +/g, '\n');
                // Replace multiple spaces (but not tabs) with single space (except in code blocks)
                reasoningText = reasoningText.replace(/[ \t]+$/gm, ''); // Remove trailing whitespace from lines
                
                // Trim leading/trailing whitespace
                reasoningText = reasoningText.trim();
                
                // Set the text content (preserves newlines with white-space: pre-wrap)
                reasoningDisplay.textContent = reasoningText || '(empty)';
                
                // Calculate and display token count (approximate: len(reasoning_0)/4)
                const originalReasoning = String(instance.reasoning_0);
                const tokenCount = Math.round(originalReasoning.length / 4);
                const tokenCountElement = document.getElementById('reasoning-token-count');
                if (tokenCountElement) {
                    tokenCountElement.textContent = `(~${tokenCount} tokens)`;
                }
                
                reasoningSection.style.display = 'block';
            } else {
                reasoningSection.style.display = 'none';
                // Clear token count if reasoning doesn't exist
                const tokenCountElement = document.getElementById('reasoning-token-count');
                if (tokenCountElement) {
                    tokenCountElement.textContent = '';
                }
            }

            // Display paths in a table (using pre-processed data)
            const processedPaths = instance.processed_paths || [];
            if (DEBUG_PATHS) {
                console.group('[DEBUG] displayData paths');
                console.log('instance index:', index, 'processed_paths length:', processedPaths.length);
                processedPaths.forEach((p, i) => console.log(`  [${i}] path:`, p.path, 'valid:', p.valid, 'factual:', p.factual, 'quality:', p.quality));
                console.groupEnd();
            }

            const tbody = document.getElementById('paths-tbody');
            tbody.innerHTML = '';

            // Helper function to format path with arrows
            // Python already provides paths as a list of triples, so we just format them
            function formatPathWithArrows(pathTriples) {
                if (!pathTriples || pathTriples.length === 0) return '';
                
                if (!Array.isArray(pathTriples)) {
                    let str = String(pathTriples);
                    // Remove single quotes and replace square brackets with round brackets
                    str = str.replace(/'/g, '');
                    str = str.replace(/\[/g, '(');
                    str = str.replace(/\]/g, ')');
                    return str;
                }
                
                const parts = [];
                
                // Format all triples with parentheses and arrows
                // pathTriples should already be a list of triples: [[entity, relation, entity], [entity, relation, entity], ...]
                for (let i = 0; i < pathTriples.length; i++) {
                    const triple = pathTriples[i];
                    if (Array.isArray(triple) && triple.length >= 2) {
                        // Start triple with opening parenthesis
                        parts.push('<span class="triple-start">(</span>');
                        
                        // First entity of triple
                        if (triple[0]) {
                            let entity = String(triple[0]);
                            // Remove single quotes and replace square brackets with round brackets
                            entity = entity.replace(/'/g, '');
                            entity = entity.replace(/\[/g, '(');
                            entity = entity.replace(/\]/g, ')');
                            parts.push(`<span class="path-entity">${entity}</span>`);
                        }
                        // Relation
                        if (triple[1]) {
                            parts.push('<span class="path-arrow"> ‚Üí </span>');
                            let relation = String(triple[1]);
                            // Remove single quotes and replace square brackets with round brackets
                            relation = relation.replace(/'/g, '');
                            relation = relation.replace(/\[/g, '(');
                            relation = relation.replace(/\]/g, ')');
                            parts.push(`<span class="path-relation">${relation}</span>`);
                        }
                        // Second entity (if exists)
                        if (triple[2]) {
                            parts.push('<span class="path-arrow"> ‚Üí </span>');
                            let entity = String(triple[2]);
                            // Remove single quotes and replace square brackets with round brackets
                            entity = entity.replace(/'/g, '');
                            entity = entity.replace(/\[/g, '(');
                            entity = entity.replace(/\]/g, ')');
                            parts.push(`<span class="path-entity">${entity}</span>`);
                        }
                        
                        // Close triple with closing parenthesis
                        parts.push('<span class="triple-end">)</span>');
                        
                        // Add arrow between triples (but not after the last one)
                        if (i < pathTriples.length - 1) {
                            parts.push('<span class="path-arrow"> ‚Üí </span>');
                        }
                    }
                }
                
                return parts.length > 0 ? parts.join('') : String(pathTriples);
            }
            
            // Helper function to format quality as stars
            function formatQualityStars(value) {
                const numValue = parseFloat(value);
                if (isNaN(numValue) || numValue === null || numValue === undefined) return 'N/A';
                
                const maxStars = 5;
                // Scale value to 0-5 range (assuming quality is 0-5 or similar)
                const scaledValue = Math.min(Math.max(numValue, 0), maxStars);
                const filledStars = Math.round(scaledValue);
                const emptyStars = maxStars - filledStars;
                
                let starsHTML = '';
                for (let i = 0; i < filledStars; i++) {
                    starsHTML += '<span class="quality-star">‚òÖ</span>';
                }
                for (let i = 0; i < emptyStars; i++) {
                    starsHTML += '<span class="quality-star empty">‚òÖ</span>';
                }
                return starsHTML;
            }

            // Keep only paths that are structurally valid AND factually correct
            const filteredPaths = processedPaths.filter(entry => {
                const valid = entry.valid === true || entry.valid === 1 || entry.valid === '1' || String(entry.valid).toLowerCase() === 'true';
                const factual = entry.factual === true || entry.factual === 1 || entry.factual === '1' || String(entry.factual).toLowerCase() === 'true';
                return valid && factual;
            });
            if (DEBUG_PATHS) {
                console.log('[DEBUG] After filter (valid+factual):', processedPaths.length, '->', filteredPaths.length, 'paths');
            }

            if (filteredPaths.length > 0) {
                filteredPaths.forEach((entry, index) => {
                    const tr = document.createElement('tr');
                    tr.setAttribute('data-path-index', index);
                    
                    // Store original data as data attributes for filtering
                    const qualityNum = parseFloat(entry.quality) || 0;
                    const pathText = JSON.stringify(entry.path).toLowerCase();
                    
                    tr.setAttribute('data-quality', qualityNum);
                    tr.setAttribute('data-path-text', pathText);
                    
                    // Path column - format with arrows
                    const pathCell = document.createElement('td');
                    pathCell.className = 'path-cell';
                    // entry.path should already be a list of triples from Python
                    const pathHTML = formatPathWithArrows(entry.path);
                    pathCell.innerHTML = `<div class="path-step">${pathHTML}</div>`;
                    tr.appendChild(pathCell);
                    
                    // Quality column with stars (only column shown besides path)
                    const qualityCell = document.createElement('td');
                    qualityCell.className = 'score-cell';
                    const qualityValue = entry.quality;
                    const qualityBadge = document.createElement('span');
                    qualityBadge.className = 'quality-stars';
                    qualityBadge.innerHTML = formatQualityStars(qualityValue);
                    qualityCell.appendChild(qualityBadge);
                    tr.appendChild(qualityCell);
                    
                    tbody.appendChild(tr);
                });
                
                // Apply initial filters
                applyFilters();
            } else {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = 2;
                td.textContent = '(no paths)';
                td.style.textAlign = 'center';
                td.style.padding = '20px';
                td.style.color = '#999';
                tr.appendChild(td);
                tbody.appendChild(tr);
            }

            // Calculate and display prediction statistics
            const totalPaths = processedPaths.length;
            const keptPaths = filteredPaths.length;
            
            const statsElement = document.getElementById('predictions-stats');
            if (statsElement && totalPaths > 0) {
                // statsElement.textContent =``;  `${keptPaths}/${totalPaths} paths are valid and factually correct`;
                statsElement.textContent =``;
            } else if (statsElement) {
                statsElement.textContent = '';
            }

            // Update index info
            document.getElementById('index-info').textContent = 
                `Instance ${currentIndex + 1} of ${totalInstances}`;
            document.getElementById('index-input').value = currentIndex;

            document.getElementById('data-display').style.display = 'block';
        }

        // Filter functions
        function applyFilters() {
            const qualityFilter = document.getElementById('filter-quality').value;
            const searchTerm = document.getElementById('filter-search').value.toLowerCase().trim();
            
            const rows = document.querySelectorAll('#paths-tbody tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const quality = parseFloat(row.getAttribute('data-quality')) || 0;
                const pathText = row.getAttribute('data-path-text') || '';
                
                let show = true;
                // Apply quality filter
                if (qualityFilter !== '' && quality < parseFloat(qualityFilter)) {
                    show = false;
                }
                
                // Apply search filter
                if (searchTerm && !pathText.includes(searchTerm)) {
                    show = false;
                }
                
                // Show/hide row
                if (show) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update filter bar to show count (optional)
            // Could add a "Showing X of Y" indicator here
        }
        
        // Set up filter event listeners
        function setupFilters() {
            document.getElementById('filter-quality').addEventListener('change', applyFilters);
            document.getElementById('filter-search').addEventListener('input', applyFilters);
        }
        
        // Initialize filters when page loads
        setupFilters();

        // Navigation functions
        async function navigateNext() {
            if (currentDataset && currentIndex < currentDataset.length - 1) {
                await displayData(currentIndex + 1);
            } else if (currentDataset && currentIndex === currentDataset.length - 1) {
                await displayData(0); // Wrap around
            }
        }

        async function navigatePrev() {
            if (currentDataset && currentIndex > 0) {
                await displayData(currentIndex - 1);
            } else if (currentDataset && currentIndex === 0) {
                await displayData(currentDataset.length - 1); // Wrap around
            }
        }

        async function navigateToIndex(index) {
            if (currentDataset && index >= 0 && index < currentDataset.length) {
                await displayData(index);
            } else {
                showError(`Index ${index} is out of range (0-${currentDataset.length - 1})`);
            }
        }

        // Event handlers
        document.getElementById('next-btn').addEventListener('click', navigateNext);
        document.getElementById('prev-btn').addEventListener('click', navigatePrev);
        document.getElementById('jump-btn').addEventListener('click', function() {
            const index = parseInt(document.getElementById('index-input').value);
            navigateToIndex(index);
        });

        // Utility functions
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error-message').style.display = 'none';
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Setup reasoning section toggle
        function setupReasoningToggle() {
            const reasoningHeader = document.getElementById('reasoning-header');
            const reasoningSection = document.getElementById('reasoning-section');
            
            if (reasoningHeader && reasoningSection) {
                reasoningHeader.addEventListener('click', function() {
                    reasoningSection.classList.toggle('collapsed');
                });
            }
        }
        
        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Only handle shortcuts when data is displayed and not typing in input
                if (!currentDataset || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                    return;
                }
                
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (e.key === 'ArrowLeft') {
                        navigatePrev();
                    } else {
                        navigateNext();
                    }
                }
            });
        }
        
        // Initialize on page load
        initPyodide(); // Initialize Python runtime
        setupKeyboardShortcuts(); // Setup keyboard navigation
        setupReasoningToggle(); // Setup reasoning section toggle

        // Build tab bar and load first tab
        async function initTabs() {
            const container = document.getElementById('data-tabs');
            container.innerHTML = '';
            if (DATA_TABS.length === 0) return;
            DATA_TABS.forEach((tab, index) => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'data-tab' + (index === 0 ? ' active' : '');
                btn.textContent = tab.label;
                btn.setAttribute('data-file', tab.file);
                btn.setAttribute('role', 'tab');
                btn.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
                btn.addEventListener('click', async () => {
                    container.querySelectorAll('.data-tab').forEach((b, i) => {
                        b.classList.toggle('active', i === index);
                        b.setAttribute('aria-selected', i === index ? 'true' : 'false');
                    });
                    try {
                        showLoading(true);
                        hideError();
                        currentDataset = await loadDatasetFromFile(tab.file);
                        totalInstances = currentDataset.length;
                        await displayData(0);
                    } catch (error) {
                        showError('Error loading dataset: ' + error.message);
                        console.error('Tab load error:', error);
                    } finally {
                        showLoading(false);
                    }
                });
                container.appendChild(btn);
            });
            // Load first tab
            try {
                showLoading(true);
                hideError();
                currentDataset = await loadDatasetFromFile(DATA_TABS[0].file);
                totalInstances = currentDataset.length;
                await displayData(0);
            } catch (error) {
                showError('Error loading dataset: ' + error.message);
                console.error('Initial tab load error:', error);
            } finally {
                showLoading(false);
            }
        }

        (async () => {
            await initPyodide();
            await initTabs();
        })();
    </script>
</body>
</html>
